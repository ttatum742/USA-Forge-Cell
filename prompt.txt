ultrathink: 

I have restructured the project folder again. The only changed file locations are the programs. I organized the python program folder to separate the force sensing programs from the die scanner programs. Please review and familiarize yourself with the new structure, starting in the main project folder and working your way through the subdirectories. 

Today's tasks are important. Listen carefully. 

1) Review dieScanner_keyence_dbGoodcalc.py and create a md file containing a "summary" of the program functionality. This will be used in the next task. 

2) We are going to build a production ready python package out of the dieScanner_keyence_dbGoodcalc.py program. We can use the summary markdown file you made in task one to help keep you on track while developing this new package. This python package should be located in Programs/Python/dieScanner/diescanProd. This python package should follow the python_project_structure_guide.md, found in the main project folder. This python package should only utilize the necessary parts of dieScanner_keyence_dbGoodcalc, and should omit parts that are currently unused. Same goes for package dependencies. This python package should avoid circular dependencies. In general, you want higher-level modules dependent on lower-level modules. Key differences in this new package vs our debugging program are: this package will be deployable, this package will need to compute faster (which is why we are trying to get rid of unused code), this package will need to have much more stringent failure modes. On the failure mode point, I mean that the new package should not allow a run with only 50% angular coverage and a wildly inaccurate center estimation to be passed to the robot. Any incorrect center calculation that makes it through to the robot could potentially kill any nearby operators if the 2000degF part is placed incorrectly and the stamping press actuates. We need absolute confidence that the center value being calculated is the true center value of the die. This is a matter of life or death. Moreover, the new package should not have the cpppo communications with the robot logged (at a low level) in the terminal. We only want to see basic information (ie center calc, pass fail, other data useful to operators). No need to save a CSV afterwards. This package should also have very fast initialization time. The robot will need to signal to the PC that it is ready for the dieScan routine to begin. This can be accomplished in the same way that the torque_monitor.py program is called (with batch automation, program always running in background) OR you can come up with another method that triggers this package to run when the robot is ready to scan the die.

3) I need to build out some logging programs on the robot, and within python. Go ahead and build another python package folder called 'logger' using the same python_project_structure_guide.md and begin to create a logging package template. This logger will ultimately read registers from the robot after each job is complete (or aborted) and store them in a CSV file for later use. We can build out the fanuc side of this later. Just need a package template that follows the same basic communication logic as other python packages we have built for this robot cell. We can figure out exactly what we are logging later. 
