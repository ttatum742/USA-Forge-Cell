/PROG  DIESCAN_DEBUG
/ATTR
OWNER		= ASCBIN;
COMMENT		= "";
PROG_SIZE	= 1200;
CREATE		= DATE 25-07-07  TIME 14:00:00;
MODIFIED	= DATE 25-07-07  TIME 14:00:00;
FILE_NAME	= ;
VERSION		= 0;
LINE_COUNT	= 196;
MEMORY_SIZE	= 2000;
PROTECT		= READ_WRITE;
TCD:  STACK_SIZE	= 0,
     TASK_PRIORITY	= 50,
     TIME_SLICE	= 0,
     BUSY_LAMP_OFF	= 0,
     ABORT_REQUEST	= 0,
     PAUSE_REQUEST	= 0;
DEFAULT_GROUP	= 1,*,*,*,*;
CONTROL_CODE	= 00000000 00000000;
LOCAL_REGISTERS	= 0,0,0;
/APPL
AUTO_SINGULARITY_HEADER;
  ENABLE_SINGULARITY_AVOIDANCE   : TRUE;
/MN
   1:  !Die Scanner Debug Coordinator ;
   2:  !Corresponds to dieScanner_keyence_debug.py ;
   3:  !Uses new register assignments R86 to R189 ;
   4:  !Updated: 2025-07-07 ;
   5:   ;
   6:  !Die Scan Communication Registers: ;
   7:  !R86 = Command from PC (1=pickup, 2=move_start, 5=scan, 7=final) ;
   8:  !R87 = Status to PC (0=ready, 1=busy, 2=complete, 3=error) ;
   9:  !R88 = Current X position (updated every 4ms) ;
  10:  !R89 = Current Y position (updated every 4ms) ;
  11:  !R90 = Current Z position (updated every 4ms) ;
  12:  !R91 = Point counter ;
  13:  !R92 = Total points ;
  14:  !R93 = Final center X result ;
  15:  !R94 = Final center Y result ;
  16:  !R95 = Average die height ;
  17:  !R96 = Confidence level (0-100%) ;
  18:  !R97 = Return address for jump logic ;
  19:   ;
  20:  !Initialize communication ;
  21:  R[86:ds_command]=0 ;
  22:  R[87:ds_status]=0 ;
  23:  R[91:ds_point_counter]=0 ;
  24:   ;
  25:  !Start position update background task ;
  26:  R[97:return_addr]=1 ;
  27:  JMP LBL[50] ;
  28:   ;
  29:  LBL[1]  ;
  30:  !Main command processing loop ;
  31:   ;
  32:  !Position calculated on-demand using LPOS ;
  33:  !Check if PC requests position update ;
  34:  IF (R[185:ds_pos_request]=1) THEN  ;
  35:  PR[38:current_pos_calc]=LPOS ;
  36:  R[88:ds_current_x]=PR[38,1:current_pos_calc] ;
  37:  R[89:ds_current_y]=PR[38,2:current_pos_calc] ;
  38:  R[90:ds_current_z]=PR[38,3:current_pos_calc] ;
  39:  R[185:ds_pos_request]=0 ;
  40:  ELSE ;
  41:  ENDIF ;
  42:   ;
  43:  !Check for commands from PC ;
  44:  IF (R[86:ds_command]=1) THEN ;
  45:  !Command 1: Pick up sensor jig ;
  46:  R[87:ds_status]=1 ;
  47:  R[97:return_addr]=2 ;
  48:  JMP LBL[10] ;
  49:  ELSE ;
  50:  ENDIF ;
  51:   ;
  52:  LBL[2] ;
  53:  IF (R[86:ds_command]=2) THEN ;
  54:  !Command 2: Move to scan start position ;
  55:  R[87:ds_status]=1 ;
  56:  R[97:return_addr]=3 ;
  57:  JMP LBL[20] ;
  58:  ELSE ;
  59:  ENDIF ;
  60:   ;
  61:  LBL[3] ;
  62:  IF (R[86:ds_command]=5) THEN ;
  63:  !Command 5: Start continuous scanning motion ;
  64:  R[87:ds_status]=1 ;
  65:  R[97:return_addr]=4 ;
  66:  JMP LBL[30] ;
  67:  ELSE ;
  68:  ENDIF ;
  69:   ;
  70:  LBL[4] ;
  71:  IF (R[86:ds_command]=7) THEN ;
  72:  !Command 7: Move to final position ;
  73:  R[87:ds_status]=1 ;
  74:  R[97:return_addr]=5 ;
  75:  JMP LBL[40] ;
  76:  ELSE ;
  77:  ENDIF ;
  78:   ;
  79:  LBL[5] ;
  80:  !Small delay to prevent overwhelming the CPU ;
  81:  WAIT    .050(sec) ;
  82:   ;
  83:  !Loop back to check for more commands ;
  84:  JMP LBL[1] ;
  85:   ;
  86:  !============================================ ;
  87:  !Subroutines with return jump logic ;
  88:  !============================================ ;
  89:   ;
  90:  LBL[10] ;
  91:  !Step 1: Pick up sensor jig from fixture - COMMENTED OUT FOR TESTING ;
  92:  MESSAGE[Sensor jig already in gripper - skipping pickup] ;
  93://J PR[35] 100% FINE    ;
  94:  !Add gripper close logic here if needed ;
  95:  MESSAGE[Sensor jig pickup skipped] ;
  96:  R[86:ds_command]=0 ;
  97:  R[87:ds_status]=0 ;
  98:  !Return to caller ;
  99:  IF (R[97:return_addr]=2) THEN ;
 100:  JMP LBL[2] ;
 101:  ELSE ;
 102:  ENDIF ;
 103:   ;
 104:  LBL[20] ;
 105:  !Step 2: Move to scan start position (65mm above static point) ;
 106:  MESSAGE[Moving to scan start position] ;
 107:J PR[36:die_scan_start] 50% FINE    ;
 108:  MESSAGE[At scan start position] ;
 109:  R[86:ds_command]=0 ;
 110:  R[87:ds_status]=0 ;
 111:  !Return to caller ;
 112:  IF (R[97:return_addr]=3) THEN ;
 113:  JMP LBL[3] ;
 114:  ELSE ;
 115:  ENDIF ;
 116:   ;
 117:  LBL[30] ;
 118:  !Step 5: Start continuous scanning motion ;
 119:  !PC calculates all positions, robot just moves ;
 120:  MESSAGE[Starting continuous scan motion] ;
 121:   ;
 122:  !Signal PC that scanning motion is ready ;
 123:  R[87:ds_status]=10 ;
 124:   ;
 125:  LBL[31] ;
 126:  !Wait for PC to calculate next position ;
 127:  !PC writes coordinates to R182-R184 when ready ;
 128:  !Added timeout to detect Python program failure ;
 129:  TIMER[1]=0 ;
 130:  LBL[35] ;
 131:  IF (R[87:ds_status]=11) THEN ;
 132:  JMP LBL[36] ;
 133:  ELSE ;
 134:  ENDIF ;
 135:  IF (TIMER[1]>=30) THEN ;
 136:  MESSAGE[ERROR: Python program timeout - no response in 30 seconds] ;
 137:  R[87:ds_status]=3 ;
 138:  JMP LBL[99] ;
 139:  ELSE ;
 140:  ENDIF ;
 141:  WAIT    .100(sec) ;
 142:  JMP LBL[35] ;
 143:  LBL[36] ;
 129:   ;
 130:  !Copy PC-calculated position from numerical registers to PR[37] ;
 131:  PR[37,1:scan_point_calc]=R[182:ds_next_pos_x] ;
 132:  PR[37,2:scan_point_calc]=R[183:ds_next_pos_y] ;
 133:  PR[37,3:scan_point_calc]=R[184:ds_next_pos_z] ;
 134:   ;
 135:  !Move to PC-calculated position ;
 136:L PR[37:scan_point_calc] 200mm/sec CNT50    ;
 137:   ;
 138:  !Signal PC that move is complete ;
 139:  R[87:ds_status]=10 ;
 140:   ;
 141:  !Check if PC found sufficient edges - removed confidence check during scanning ;
 142:  !Confidence is only calculated after scanning is complete ;
 143:  !IF (R[96:ds_confidence]>=70) THEN ;
 144:  !MESSAGE[Sufficient edges detected] ;
 145:  !JMP LBL[32] ;
 146:  !ELSE ;
 147:  !ENDIF ;
 147:   ;
 148:  !Check if PC signals scan complete ;
 149:  IF (R[87:ds_status]=12) THEN ;
 150:  JMP LBL[32] ;
 151:  ELSE ;
 152:  ENDIF ;
 153:   ;
 154:  !Continue scanning loop ;
 155:  JMP LBL[31] ;
 156:   ;
 157:  LBL[32] ;
 158:  MESSAGE[Continuous scan complete] ;
 159:  R[86:ds_command]=0 ;
 160:  R[87:ds_status]=0 ;
 161:  !Return to caller ;
 162:  IF (R[97:return_addr]=4) THEN ;
 163:  JMP LBL[4] ;
 164:  ELSE ;
 165:  ENDIF ;
 166:   ;
 167:  LBL[40] ;
 168:  !Step 7: Move 100mm above calculated center ;
 169:  MESSAGE[Moving to final position] ;
 170:   ;
 171:  !Use calculated center from PC ;
 172:  PR[44,1:scan_complete_pos]=R[93:ds_center_x] ;
 173:  PR[44,2:scan_complete_pos]=R[94:ds_center_y] ;
 174:  PR[44,3:scan_complete_pos]=R[95:ds_avg_height]+100 ;
 175:   ;
 176:  !Move to final position ;
 177:J PR[44:scan_complete_pos] 50% FINE    ;
 178:   ;
 179:  MESSAGE[At final position above die center] ;
 180:  R[86:ds_command]=0 ;
 181:  R[87:ds_status]=0 ;
 182:  !Return to caller ;
 183:  IF (R[97:return_addr]=5) THEN ;
 184:  JMP LBL[5] ;
 185:  ELSE ;
 186:  ENDIF ;
 187:   ;
 188:  LBL[99] ;
 189:  !Error handler - Python program failed ;
 190:  MESSAGE[PROGRAM ABORTED: Python program failed or timed out] ;
 191:  R[86:ds_command]=0 ;
 192:  R[87:ds_status]=3 ;
 193:  ABORT ;
 194:   ;
 195:  LBL[50] ;
 196:  !Initialize position tracking - called once at start ;
 197:  MESSAGE[Position tracking initialized] ;
 191:  !Return to main loop after initialization ;
 192:  IF (R[97:return_addr]=1) THEN ;
 193:  JMP LBL[1] ;
 194:  ELSE ;
 195:  ENDIF ;
 196:   ;
/POS
/END
